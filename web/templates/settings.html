{% extends "base.html" %}

{% block title %}Settings - Activity Tracker{% endblock %}

{% block extra_styles %}
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
        }

        @media (max-width: 600px) {
            .settings-grid {
                grid-template-columns: 1fr;
            }
        }

        .settings-section {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
        }

        .settings-section h2 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 8px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .section-icon {
            width: 20px;
            height: 20px;
            stroke: var(--accent);
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
        }

        .settings-row:last-child {
            border-bottom: none;
        }

        .settings-row.column {
            flex-direction: column;
            align-items: stretch;
        }

        .settings-label {
            flex: 1;
            min-width: 0;
        }

        .settings-label h3 {
            font-size: 0.95rem;
            font-weight: 500;
            margin-bottom: 2px;
            color: var(--text);
        }

        .settings-label p {
            font-size: 0.8rem;
            color: var(--muted);
        }

        .settings-control {
            flex: 0 0 220px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @media (max-width: 600px) {
            .settings-row {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            .settings-control {
                flex: 1;
            }
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: var(--border);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
        }

        .slider-value {
            min-width: 50px;
            text-align: right;
            font-variant-numeric: tabular-nums;
            font-size: 0.9rem;
            color: var(--text);
            font-weight: 500;
        }

        select, input[type="text"] {
            background: var(--surface-2);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.85rem;
            width: 100%;
            transition: border-color 0.2s;
        }

        select:hover, input[type="text"]:hover {
            border-color: var(--accent);
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--shadow-accent);
        }

        .toggle {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 22px;
            flex-shrink: 0;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border);
            transition: .3s;
            border-radius: 22px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        .toggle input:checked + .toggle-slider {
            background-color: var(--accent);
        }

        .toggle input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        button {
            background: var(--accent);
            color: var(--text-inverse);
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: var(--accent-strong);
        }

        button.secondary {
            background: var(--surface-2);
            color: var(--text);
            border: 1px solid var(--border);
        }

        button.secondary:hover {
            background: var(--border);
            border-color: var(--accent);
        }

        button.danger {
            background: var(--danger);
        }

        button.danger:hover {
            background: #b91c1c;
        }

        .status-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .status-badge.running {
            background: rgba(63, 185, 80, 0.15);
            color: var(--success);
        }

        .status-badge.stopped {
            background: rgba(248, 81, 73, 0.15);
            color: var(--danger);
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-soft));
            transition: width 0.3s;
            border-radius: 3px;
        }

        .monitor-list {
            list-style: none;
            margin-top: 12px;
        }

        .monitor-item {
            padding: 10px 12px;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .monitor-item:last-child {
            margin-bottom: 0;
        }

        .monitor-item.primary {
            border-left: 3px solid var(--accent);
        }

        .monitor-icon {
            width: 16px;
            height: 16px;
            stroke: var(--muted);
            fill: none;
            stroke-width: 2;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            display: none;
            animation: slideIn 0.3s;
            font-size: 0.9rem;
            z-index: 1000;
        }

        .toast.show {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toast.success {
            border-left: 3px solid var(--success);
        }

        .toast.error {
            border-left: 3px solid var(--danger);
        }

        .toast.warning {
            border-left: 3px solid var(--warning);
        }

        @keyframes slideIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .tag-input-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            min-height: 80px;
            margin-top: 12px;
            transition: border-color 0.2s;
        }

        .tag-input-container:focus-within {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--shadow-accent);
        }

        .tag {
            background: var(--surface);
            border: 1px solid var(--border);
            padding: 4px 10px;
            border-radius: 4px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
        }

        .tag-remove {
            cursor: pointer;
            color: var(--muted);
            font-weight: bold;
            line-height: 1;
            transition: color 0.2s;
        }

        .tag-remove:hover {
            color: var(--danger);
        }

        .tag-input {
            flex: 1;
            min-width: 150px;
            border: none;
            background: none;
            color: var(--text);
            outline: none;
            font-size: 0.85rem;
            padding: 4px;
        }

        .tag-input::placeholder {
            color: var(--muted);
        }

        .actions-row {
            display: flex;
            gap: 12px;
            padding-top: 12px;
            flex-wrap: wrap;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent);
        }

        .storage-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .storage-text {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
        }

        .storage-used {
            color: var(--text);
            font-weight: 500;
        }

        .storage-max {
            color: var(--muted);
        }

        .restart-notice {
            font-size: 0.75rem;
            color: var(--warning);
            margin-top: 4px;
        }

        /* Sticky Save Bar */
        .save-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--surface);
            border-top: 1px solid var(--border);
            padding: 12px 20px;
            z-index: 1000;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(0);
            transition: transform 0.3s ease;
        }

        .save-bar.hidden {
            transform: translateY(100%);
        }

        .save-bar-content {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .unsaved-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--warning);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .save-buttons {
            display: flex;
            gap: 10px;
        }

        .restart-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--warning);
            color: #000;
        }

        .restart-btn:hover {
            background: #b88a00;
        }

        /* Add bottom padding to container when save bar is visible */
        body.has-unsaved .container {
            padding-bottom: 80px;
        }

        /* Input changed indicator */
        .input-changed {
            border-color: var(--warning) !important;
            box-shadow: 0 0 0 2px rgba(210, 153, 34, 0.2) !important;
        }

        .toggle input:not(:checked) + .toggle-slider.changed,
        .toggle input:checked + .toggle-slider.changed {
            box-shadow: 0 0 0 2px rgba(210, 153, 34, 0.4);
        }

        /* Unsaved Changes Banner */
        .unsaved-banner {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: rgba(210, 153, 34, 0.15);
            border: 1px solid var(--warning);
            border-radius: 6px;
            color: var(--warning);
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 16px;
        }

        .unsaved-banner.hidden {
            display: none;
        }

        /* Actions Divider */
        .actions-divider {
            border: none;
            border-top: 1px solid var(--border);
            margin: 16px 0;
        }

        /* Button with icon */
        button svg {
            flex-shrink: 0;
        }

        #saveActions button,
        .actions-row button {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        /* Disabled state for save buttons when no changes */
        #saveBtn:disabled,
        #discardBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #saveRestartBtn {
            display: none;
        }

        #saveRestartBtn.visible {
            display: inline-flex;
        }

        /* Refresh button for models dropdown */
        .refresh-btn {
            background: var(--surface-2);
            border: 1px solid var(--border);
            color: var(--muted);
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .refresh-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--text-inverse);
        }

        .refresh-btn.loading svg {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Content Mode Checkboxes */
        .content-mode-checkboxes {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 12px;
        }

        .checkbox-label {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px 12px;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .checkbox-label:hover {
            border-color: var(--accent);
        }

        .checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-top: 2px;
            accent-color: var(--accent);
            cursor: pointer;
        }

        .checkbox-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .checkbox-text strong {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text);
        }

        .checkbox-text small {
            font-size: 0.75rem;
            color: var(--muted);
        }

        /* Advanced Settings Toggle */
        .advanced-settings-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 0;
            cursor: pointer;
            color: var(--accent);
            font-size: 0.9rem;
            font-weight: 500;
            transition: color 0.2s;
        }

        .advanced-settings-toggle:hover {
            color: var(--accent-soft);
        }

        .collapse-arrow {
            width: 16px;
            height: 16px;
            transition: transform 0.2s;
        }

        .collapse-arrow.expanded {
            transform: rotate(90deg);
        }

        /* Advanced Settings Container */
        .advanced-settings {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            border-top: 1px solid var(--border);
            padding-top: 12px;
        }

        .advanced-settings.collapsed {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            border-top: none;
        }

        /* Underlying Settings (from preset) */
        .underlying-settings {
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
        }

        .underlying-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 0.85rem;
            color: var(--muted);
        }

        .preset-badge {
            background: var(--accent);
            color: var(--text-inverse);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: capitalize;
        }

        .settings-row.compact {
            padding: 8px 0;
        }

        .settings-row.compact .settings-label h3 {
            font-size: 0.85rem;
        }

        .computed-note {
            font-size: 0.7rem;
            color: var(--muted);
            font-style: italic;
        }

        .computed-value {
            font-size: 0.9rem;
            color: var(--text);
            font-variant-numeric: tabular-nums;
        }

        /* Prompt Preview */
        .prompt-preview-section {
            margin-top: 16px;
            border-top: 1px solid var(--border);
            padding-top: 16px;
        }

        .prompt-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .prompt-preview-header h3 {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text);
        }

        button.small {
            padding: 4px 10px;
            font-size: 0.75rem;
        }

        .prompt-preview {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .prompt-preview.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .prompt-preview pre {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            font-size: 0.75rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 300px;
            overflow-y: auto;
            color: var(--text);
            line-height: 1.5;
        }

        /* Tag Management Styles */
        .tag-actions {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 10px;
        }

        .analysis-status {
            font-size: 0.85rem;
            color: var(--muted);
        }

        .analysis-status.loading {
            color: var(--accent);
        }

        .analysis-status.error {
            color: var(--danger);
        }

        .analysis-status.success {
            color: var(--success);
        }

        .tag-consolidation-results {
            margin-top: 16px;
            padding: 16px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        .consolidation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .consolidation-header h4 {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text);
            margin: 0;
        }

        .select-all-toggle label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            color: var(--muted);
            cursor: pointer;
        }

        .consolidation-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .consolidation-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: 8px;
            background: var(--surface);
            transition: border-color 0.2s;
        }

        .consolidation-item:hover {
            border-color: var(--accent);
        }

        .consolidation-item.selected {
            border-color: var(--accent);
            background: rgba(var(--accent-rgb), 0.05);
        }

        .consolidation-checkbox {
            margin-top: 2px;
        }

        .consolidation-content {
            flex: 1;
            min-width: 0;
        }

        .consolidation-canonical {
            font-weight: 600;
            color: var(--accent);
            font-size: 0.95rem;
            margin-bottom: 4px;
        }

        .consolidation-canonical .arrow {
            color: var(--muted);
            margin: 0 4px;
        }

        .consolidation-variants {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
        }

        .variant-tag {
            display: inline-block;
            padding: 2px 8px;
            font-size: 0.8rem;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--text);
        }

        .variant-tag.canonical {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--text-inverse);
        }

        .consolidation-count {
            font-size: 0.8rem;
            color: var(--muted);
            margin-top: 6px;
        }

        .consolidation-actions {
            display: flex;
            gap: 10px;
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .consolidation-actions button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Tag Cloud & Manual Merge */
        .tag-search-row {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .tag-search-row input {
            flex: 1;
        }

        .tag-cloud {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
        }

        .tag-cloud .loading-text {
            color: var(--muted);
            font-size: 0.85rem;
        }

        .tag-cloud-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            font-size: 0.85rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            user-select: none;
        }

        .tag-cloud-item:hover {
            border-color: var(--accent);
            background: var(--surface-2);
        }

        .tag-cloud-item.selected {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--text-inverse);
        }

        .tag-cloud-item .tag-count {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .tag-cloud-item.hidden {
            display: none;
        }

        .merge-controls {
            margin-top: 12px;
            padding: 12px;
            background: var(--surface-2);
            border-radius: 8px;
            border: 1px solid var(--accent);
        }

        .merge-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 0.9rem;
            color: var(--text);
        }

        .text-btn {
            background: none;
            border: none;
            color: var(--accent);
            cursor: pointer;
            font-size: 0.85rem;
            padding: 0;
        }

        .text-btn:hover {
            text-decoration: underline;
        }

        .merge-input-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .merge-input-row label {
            font-size: 0.85rem;
            color: var(--muted);
            white-space: nowrap;
        }

        .merge-input-row input {
            flex: 1;
            max-width: 250px;
        }
{% endblock %}

{% block content %}
        <div class="settings-grid">
            <!-- Capture Settings -->
            <div class="settings-section">
                <h2>
                    <svg class="section-icon" viewBox="0 0 24 24">
                        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                        <circle cx="12" cy="13" r="4"></circle>
                    </svg>
                    Capture
                </h2>

                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Interval</h3>
                        <p>Time between screenshots</p>
                        <span class="restart-notice">Requires restart</span>
                    </div>
                    <div class="settings-control">
                        <input type="range" id="interval_seconds" min="10" max="120" step="10">
                        <span class="slider-value"><span id="interval_seconds_value">30</span>s</span>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Format</h3>
                        <p>Screenshot file format</p>
                    </div>
                    <div class="settings-control">
                        <select id="format">
                            <option value="webp">WebP (recommended)</option>
                            <option value="png">PNG</option>
                            <option value="jpg">JPEG</option>
                        </select>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Quality</h3>
                        <p>Compression quality</p>
                    </div>
                    <div class="settings-control">
                        <input type="range" id="quality" min="50" max="100" step="5">
                        <span class="slider-value"><span id="quality_value">80</span>%</span>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Active Monitor Only</h3>
                        <p>Only capture focused monitor</p>
                    </div>
                    <div class="settings-control">
                        <label class="toggle">
                            <input type="checkbox" id="capture_active_monitor_only">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- AFK Detection -->
            <div class="settings-section">
                <h2>
                    <svg class="section-icon" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                    AFK Detection
                </h2>

                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Timeout</h3>
                        <p>Inactivity before marking AFK</p>
                        <span class="restart-notice">Requires restart</span>
                    </div>
                    <div class="settings-control">
                        <input type="range" id="timeout_seconds" min="60" max="600" step="30">
                        <span class="slider-value"><span id="timeout_seconds_value">180</span>s</span>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Min Session Length</h3>
                        <p>Minimum session duration to keep</p>
                    </div>
                    <div class="settings-control">
                        <input type="range" id="min_session_minutes" min="1" max="30" step="1">
                        <span class="slider-value"><span id="min_session_minutes_value">5</span>m</span>
                    </div>
                </div>
            </div>

            <!-- Summarization -->
            <div class="settings-section">
                <h2>
                    <svg class="section-icon" viewBox="0 0 24 24">
                        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                    </svg>
                    AI Summarization
                </h2>

                <!-- Enable Toggle -->
                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Enable Summarization</h3>
                        <p>Automatically generate activity summaries</p>
                    </div>
                    <div class="settings-control">
                        <label class="toggle">
                            <input type="checkbox" id="summarization_enabled">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>

                <!-- Model Selection -->
                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Model</h3>
                        <p>AI model for analysis</p>
                    </div>
                    <div class="settings-control">
                        <select id="model">
                            <option value="">Loading models...</option>
                        </select>
                        <button type="button" class="refresh-btn" id="refreshModelsBtn" title="Refresh models list">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="23 4 23 10 17 10"></polyline>
                                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Summary Frequency (NEW - user-friendly time-based) -->
                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Summary Frequency</h3>
                        <p>How often to generate summaries</p>
                    </div>
                    <div class="settings-control">
                        <select id="frequency_minutes">
                            <option value="5">Every 5 minutes</option>
                            <option value="15">Every 15 minutes</option>
                            <option value="30">Every 30 minutes</option>
                            <option value="60">Every hour</option>
                        </select>
                    </div>
                </div>

                <!-- Summary Quality Preset (NEW) -->
                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Summary Quality</h3>
                        <p>Quick = faster, Thorough = more detailed</p>
                    </div>
                    <div class="settings-control">
                        <select id="quality_preset">
                            <option value="quick">Quick</option>
                            <option value="balanced">Balanced</option>
                            <option value="thorough">Thorough</option>
                        </select>
                    </div>
                </div>

                <!-- Content Mode (NEW - multi-select checkboxes) -->
                <div class="settings-row column">
                    <div class="settings-label">
                        <h3>Content to Include</h3>
                        <p>What information to send to the AI</p>
                    </div>
                    <div class="content-mode-checkboxes">
                        <label class="checkbox-label">
                            <input type="checkbox" id="include_focus_context" checked>
                            <span class="checkbox-text">
                                <strong>App/window usage breakdown</strong>
                                <small>Time spent per app (e.g., "VS Code: 45m, Firefox: 12m")</small>
                            </span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="include_screenshots" checked>
                            <span class="checkbox-text">
                                <strong>Screenshots</strong>
                                <small>Visual context of your screen</small>
                            </span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="include_ocr" checked>
                            <span class="checkbox-text">
                                <strong>OCR text</strong>
                                <small>Text extracted from screenshots</small>
                            </span>
                        </label>
                    </div>
                </div>

                <!-- Advanced Settings (Collapsible) -->
                <div class="advanced-settings-toggle" id="advancedToggle">
                    <svg id="advancedArrow" class="collapse-arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                    <span>Advanced Settings</span>
                </div>

                <div id="advancedSettings" class="advanced-settings collapsed">
                    <!-- Ollama Host -->
                    <div class="settings-row">
                        <div class="settings-label">
                            <h3>Ollama Host</h3>
                            <p>API endpoint URL</p>
                        </div>
                        <div class="settings-control">
                            <input type="text" id="ollama_host" placeholder="http://localhost:11434">
                        </div>
                    </div>

                    <!-- Crop to Window -->
                    <div class="settings-row">
                        <div class="settings-label">
                            <h3>Crop to Window</h3>
                            <p>Focus on active window only</p>
                        </div>
                        <div class="settings-control">
                            <label class="toggle">
                                <input type="checkbox" id="crop_to_window">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>

                    <!-- Underlying Settings (Updated by Quality Preset) -->
                    <div class="underlying-settings">
                        <div class="underlying-header">
                            <span>Settings from Quality Preset</span>
                            <span class="preset-badge" id="currentPresetBadge">balanced</span>
                        </div>

                        <div class="settings-row compact">
                            <div class="settings-label">
                                <h3>Max Screenshots</h3>
                            </div>
                            <div class="settings-control">
                                <input type="range" id="max_samples" min="3" max="20" step="1">
                                <span class="slider-value"><span id="max_samples_value">10</span></span>
                            </div>
                        </div>

                        <div class="settings-row compact">
                            <div class="settings-label">
                                <h3>Include Previous Context</h3>
                            </div>
                            <div class="settings-control">
                                <label class="toggle">
                                    <input type="checkbox" id="include_previous_summary">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>

                        <div class="settings-row compact">
                            <div class="settings-label">
                                <h3>Focus-Weighted Sampling</h3>
                            </div>
                            <div class="settings-control">
                                <label class="toggle">
                                    <input type="checkbox" id="focus_weighted_sampling">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>

                        <div class="settings-row compact">
                            <div class="settings-label">
                                <h3>Trigger Threshold</h3>
                                <p class="computed-note">Computed from frequency</p>
                            </div>
                            <div class="settings-control">
                                <span class="computed-value" id="trigger_threshold_display">30 screenshots</span>
                            </div>
                        </div>
                    </div>

                    <!-- Prompt Template Preview -->
                    <div class="prompt-preview-section">
                        <div class="prompt-preview-header">
                            <h3>Prompt Template</h3>
                            <button type="button" class="secondary small" id="promptPreviewToggle">
                                <span id="promptToggleText">Show</span>
                            </button>
                        </div>
                        <div id="promptPreview" class="prompt-preview collapsed">
                            <pre id="promptTemplateText">Loading prompt template...</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Storage -->
            <div class="settings-section">
                <h2>
                    <svg class="section-icon" viewBox="0 0 24 24">
                        <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                        <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                        <line x1="12" y1="22.08" x2="12" y2="12"></line>
                    </svg>
                    Storage
                </h2>

                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Data Directory</h3>
                        <p>Location for screenshots</p>
                    </div>
                    <div class="settings-control">
                        <input type="text" id="data_dir" readonly style="opacity: 0.7; cursor: not-allowed;">
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Retention Period</h3>
                        <p>Delete older data (0 = unlimited)</p>
                    </div>
                    <div class="settings-control">
                        <input type="range" id="max_days_retention" min="0" max="365" step="30">
                        <span class="slider-value"><span id="max_days_retention_value">90</span>d</span>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Max Storage</h3>
                        <p>Storage limit (0 = unlimited)</p>
                    </div>
                    <div class="settings-control">
                        <input type="range" id="max_gb_storage" min="0" max="200" step="10">
                        <span class="slider-value"><span id="max_gb_storage_value">50</span>GB</span>
                    </div>
                </div>

                <div class="settings-row column">
                    <div class="settings-label">
                        <h3>Current Usage</h3>
                    </div>
                    <div class="storage-info">
                        <div class="storage-text">
                            <span class="storage-used"><span id="storage_used">0</span> GB used</span>
                            <span class="storage-max"><span id="storage_max">50</span> GB limit</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="storage_progress" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tag Management -->
            <div class="settings-section">
                <h2>
                    <svg class="section-icon" viewBox="0 0 24 24">
                        <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                        <line x1="7" y1="7" x2="7.01" y2="7"></line>
                    </svg>
                    Tag Management
                    <span class="stat-value" style="margin-left: auto; font-weight: normal; font-size: 0.85rem;">
                        <span id="uniqueTagCount">-</span> tags
                    </span>
                </h2>

                <!-- Manual Tag Merge -->
                <div class="settings-row column">
                    <div class="settings-label">
                        <h3>Merge Tags</h3>
                        <p>Click tags below to select, then merge into a single tag</p>
                    </div>

                    <!-- Search/Filter -->
                    <div class="tag-search-row">
                        <input type="text" id="tagSearchInput" placeholder="Filter tags...">
                        <button type="button" class="secondary small" id="analyzeTagsBtn" title="Find duplicate tags automatically">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"></circle>
                                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                            </svg>
                            Find Duplicates
                        </button>
                    </div>

                    <!-- Tag Cloud (clickable tags) -->
                    <div id="tagCloud" class="tag-cloud">
                        <span class="loading-text">Loading tags...</span>
                    </div>

                    <!-- Merge Controls (shown when tags selected) -->
                    <div id="mergeControls" class="merge-controls" style="display: none;">
                        <div class="merge-info">
                            <span id="selectedTagsCount">0</span> tags selected
                            <button type="button" class="text-btn" id="clearTagsBtn">Clear</button>
                        </div>
                        <div class="merge-input-row">
                            <label for="canonicalTagInput">Merge into:</label>
                            <input type="text" id="canonicalTagInput" placeholder="canonical-tag-name">
                            <button type="button" id="mergeTagsBtn">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>
                                </svg>
                                Merge
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Auto-detected Duplicates (shown after analysis) -->
                <div id="tagConsolidationResults" class="tag-consolidation-results" style="display: none;">
                    <div class="consolidation-header">
                        <h4>Suggested Duplicates</h4>
                        <span class="select-all-toggle">
                            <label>
                                <input type="checkbox" id="selectAllConsolidations">
                                Select All
                            </label>
                        </span>
                    </div>
                    <div id="consolidationList" class="consolidation-list">
                        <!-- Dynamically populated -->
                    </div>
                    <div class="consolidation-actions">
                        <button type="button" id="applyConsolidationsBtn" disabled>
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                            Apply Selected
                        </button>
                        <button type="button" class="secondary" id="cancelConsolidationBtn">Cancel</button>
                    </div>
                </div>
            </div>

            <!-- Privacy -->
            <div class="settings-section">
                <h2>
                    <svg class="section-icon" viewBox="0 0 24 24">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                    </svg>
                    Privacy
                </h2>

                <div class="settings-row column">
                    <div class="settings-label">
                        <h3>Excluded Apps</h3>
                        <p>Apps to exclude from tracking (press Enter to add)</p>
                    </div>
                    <div id="excluded_apps_container" class="tag-input-container">
                        <input type="text" class="tag-input" id="excluded_apps_input" placeholder="Type app name and press Enter...">
                    </div>
                </div>
            </div>

            <!-- System Status -->
            <div class="settings-section">
                <h2>
                    <svg class="section-icon" viewBox="0 0 24 24">
                        <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                    </svg>
                    System Status
                </h2>

                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Ollama</h3>
                        <p>AI summarization service</p>
                    </div>
                    <div class="settings-control">
                        <span class="status-badge" id="ollama_status">Checking...</span>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-label">
                        <h3>Screenshots</h3>
                        <p>Total captured</p>
                    </div>
                    <div class="settings-control">
                        <span class="stat-value" id="screenshot_count">-</span>
                    </div>
                </div>

                <div class="settings-row column">
                    <div class="settings-label">
                        <h3>Monitors</h3>
                        <p>Detected displays</p>
                    </div>
                    <ul class="monitor-list" id="monitor_list"></ul>
                </div>
            </div>
        </div>

        <!-- Actions -->
        <div class="settings-section" style="margin-top: 20px;" id="actionsSection">
            <h2>
                <svg class="section-icon" viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                Actions
            </h2>

            <!-- Unsaved Changes Indicator -->
            <div id="unsavedIndicator" class="unsaved-banner hidden">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                <span>You have unsaved changes</span>
            </div>

            <!-- Save Actions -->
            <div class="actions-row" id="saveActions">
                <button id="saveBtn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    Save
                </button>
                <button class="restart-btn" id="saveRestartBtn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="23 4 23 10 17 10"></polyline>
                        <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                    </svg>
                    Save &amp; Restart
                </button>
                <button class="secondary" id="discardBtn">Discard Changes</button>
            </div>

            <hr class="actions-divider">

            <!-- Other Actions -->
            <div class="actions-row">
                <button class="secondary" id="exportConfigBtn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    Export Configuration
                </button>
                <button class="danger" id="resetConfigBtn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18"></path>
                        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                    </svg>
                    Reset to Defaults
                </button>
            </div>
        </div>
    </div>

    <!-- Floating Save Reminder (shows when scrolled away from Actions) -->
    <div id="saveBar" class="save-bar hidden">
        <div class="save-bar-content">
            <span class="unsaved-indicator">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                Unsaved changes
            </span>
            <div class="save-buttons">
                <button id="floatingSaveBtn">Save</button>
                <button class="restart-btn" id="floatingSaveRestartBtn" style="display: none;">Save &amp; Restart</button>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>
{% endblock %}

{% block extra_scripts %}
    <script>
        let config = {};           // Current saved config
        let originalConfig = {};   // Copy of original for comparison
        let pendingChanges = {};   // Track unsaved changes: { elementId: { section, key, value } }
        let requiresRestart = false;

        // Settings that require restart
        const restartRequiredKeys = new Set([
            'interval_seconds',
            'timeout_seconds',
            'host',
            'port',
            'data_dir'
        ]);

        // Load configuration on page load
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                config = await response.json();
                originalConfig = JSON.parse(JSON.stringify(config)); // Deep copy
                pendingChanges = {};
                requiresRestart = false;
                updateUI(config);
                updateSaveBar();
                loadStatus();
                loadOllamaModels();  // Load available models from Ollama
            } catch (error) {
                showToast('Failed to load configuration', 'error');
                console.error('Error loading config:', error);
            }
        }

        // Load available models from Ollama API
        async function loadOllamaModels() {
            const select = document.getElementById('model');
            const refreshBtn = document.querySelector('.refresh-btn');

            if (refreshBtn) refreshBtn.classList.add('loading');

            try {
                const response = await fetch('/api/ollama/models');
                const data = await response.json();

                // Clear existing options
                select.innerHTML = '';

                if (data.available && data.models.length > 0) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = `${model.name} (${model.size})`;
                        select.appendChild(option);
                    });

                    // Set current value from config
                    if (config.summarization && config.summarization.model) {
                        select.value = config.summarization.model;
                        // If current model not in list, add it
                        if (!select.value) {
                            const option = document.createElement('option');
                            option.value = config.summarization.model;
                            option.textContent = `${config.summarization.model} (not installed)`;
                            select.insertBefore(option, select.firstChild);
                            select.value = config.summarization.model;
                        }
                    }
                } else {
                    // Ollama not available - show current model only
                    const option = document.createElement('option');
                    option.value = config.summarization?.model || '';
                    option.textContent = config.summarization?.model
                        ? `${config.summarization.model} (Ollama unavailable)`
                        : 'Ollama unavailable';
                    select.appendChild(option);

                    if (data.error) {
                        console.warn('Ollama models:', data.error);
                    }
                }
            } catch (error) {
                console.error('Error loading Ollama models:', error);
                select.innerHTML = '<option value="">Failed to load models</option>';
                if (config.summarization?.model) {
                    const option = document.createElement('option');
                    option.value = config.summarization.model;
                    option.textContent = config.summarization.model;
                    select.appendChild(option);
                    select.value = config.summarization.model;
                }
            } finally {
                if (refreshBtn) refreshBtn.classList.remove('loading');
            }
        }

        // Update UI with config values
        function updateUI(cfg) {
            // Capture
            setValue('interval_seconds', cfg.capture.interval_seconds);
            setValue('format', cfg.capture.format);
            setValue('quality', cfg.capture.quality);
            setChecked('capture_active_monitor_only', cfg.capture.capture_active_monitor_only);

            // AFK
            setValue('timeout_seconds', cfg.afk.timeout_seconds);
            setValue('min_session_minutes', cfg.afk.min_session_minutes);

            // Summarization - User-facing settings
            setChecked('summarization_enabled', cfg.summarization.enabled);
            setValue('model', cfg.summarization.model);
            setValue('frequency_minutes', cfg.summarization.frequency_minutes || 15);
            setValue('quality_preset', cfg.summarization.quality_preset || 'balanced');

            // Content mode checkboxes
            setChecked('include_focus_context', cfg.summarization.include_focus_context !== false);
            setChecked('include_screenshots', cfg.summarization.include_screenshots !== false);
            setChecked('include_ocr', cfg.summarization.include_ocr !== false);

            // Advanced settings
            setValue('ollama_host', cfg.summarization.ollama_host);
            setChecked('crop_to_window', cfg.summarization.crop_to_window);
            setValue('max_samples', cfg.summarization.max_samples);
            setChecked('include_previous_summary', cfg.summarization.include_previous_summary);
            setChecked('focus_weighted_sampling', cfg.summarization.focus_weighted_sampling);

            // Update computed trigger threshold display
            updateTriggerThresholdDisplay();
            updatePresetBadge();

            // Storage
            setValue('data_dir', cfg.storage.data_dir);
            setValue('max_days_retention', cfg.storage.max_days_retention);
            setValue('max_gb_storage', cfg.storage.max_gb_storage);
            document.getElementById('storage_max').textContent = cfg.storage.max_gb_storage;

            // Privacy
            updateTags('excluded_apps', cfg.privacy.excluded_apps);
        }

        function setValue(id, value) {
            const el = document.getElementById(id);
            if (!el) return;

            if (el.type === 'range') {
                el.value = value;
                updateSliderValue(id, value);
            } else {
                el.value = value;
            }
        }

        function setChecked(id, checked) {
            const el = document.getElementById(id);
            if (el) el.checked = checked;
        }

        function updateSliderValue(id, value) {
            const valueEl = document.getElementById(id + '_value');
            if (valueEl) valueEl.textContent = value;
        }

        function updateTags(containerId, tags) {
            const container = document.getElementById(containerId + '_container');
            if (!container) return;

            const input = container.querySelector('.tag-input');
            container.innerHTML = '';

            tags.forEach(tag => {
                const tagEl = document.createElement('span');
                tagEl.className = 'tag';
                tagEl.innerHTML = `${escapeHtml(tag)} <span class="tag-remove" data-container="${containerId}" data-tag="${tag}">&times;</span>`;
                container.appendChild(tagEl);
            });

            container.appendChild(input);
        }

        function removeTag(containerId, tag) {
            if (containerId === 'excluded_apps') {
                // Get current working copy of excluded apps
                let apps = pendingChanges['excluded_apps']?.value
                    || [...config.privacy.excluded_apps];
                const index = apps.indexOf(tag);
                if (index > -1) {
                    apps.splice(index, 1);
                    trackChange('excluded_apps', 'privacy', 'excluded_apps', apps);
                    updateTags('excluded_apps', apps);
                }
            }
        }

        // Load system status
        async function loadStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();

                // Ollama status
                const ollamaStatus = document.getElementById('ollama_status');
                if (status.ollama_available) {
                    ollamaStatus.textContent = 'Available';
                    ollamaStatus.className = 'status-badge running';
                } else {
                    ollamaStatus.textContent = 'Unavailable';
                    ollamaStatus.className = 'status-badge stopped';
                }

                // Screenshot count
                document.getElementById('screenshot_count').textContent = status.screenshot_count.toLocaleString();

                // Storage usage
                const used = status.storage_used_gb;
                const max = config.storage.max_gb_storage || 50;
                const percent = max > 0 ? (used / max * 100) : 0;
                document.getElementById('storage_used').textContent = used.toFixed(2);
                document.getElementById('storage_progress').style.width = Math.min(percent, 100) + '%';

                // Monitors
                const monitorList = document.getElementById('monitor_list');
                monitorList.innerHTML = '';
                status.monitors.forEach(monitor => {
                    const li = document.createElement('li');
                    li.className = 'monitor-item' + (monitor.is_primary ? ' primary' : '');
                    li.innerHTML = `
                        <svg class="monitor-icon" viewBox="0 0 24 24">
                            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                            <line x1="8" y1="21" x2="16" y2="21"></line>
                            <line x1="12" y1="17" x2="12" y2="21"></line>
                        </svg>
                        <span>${monitor.name}: ${monitor.width}x${monitor.height}${monitor.is_primary ? ' (primary)' : ''}</span>
                    `;
                    monitorList.appendChild(li);
                });

            } catch (error) {
                console.error('Error loading status:', error);
            }
        }

        // Track a pending change (no auto-save)
        function trackChange(elementId, section, key, value) {
            pendingChanges[elementId] = { section, key, value };

            // Check if this change requires restart
            if (restartRequiredKeys.has(key)) {
                requiresRestart = true;
            }

            updateSaveBar();
            markInputChanged(elementId, true);
        }

        // Update save bar and Actions section visibility
        function updateSaveBar() {
            const saveBar = document.getElementById('saveBar');
            const unsavedIndicator = document.getElementById('unsavedIndicator');
            const saveBtn = document.getElementById('saveBtn');
            const discardBtn = document.getElementById('discardBtn');
            const saveRestartBtn = document.getElementById('saveRestartBtn');
            const floatingSaveRestartBtn = document.getElementById('floatingSaveRestartBtn');
            const hasChanges = Object.keys(pendingChanges).length > 0;

            if (hasChanges) {
                // Show unsaved indicator in Actions section
                unsavedIndicator.classList.remove('hidden');
                document.body.classList.add('has-unsaved');

                // Enable save/discard buttons
                saveBtn.disabled = false;
                discardBtn.disabled = false;

                // Show Save & Restart button if any pending change requires restart
                if (requiresRestart) {
                    saveRestartBtn.classList.add('visible');
                    floatingSaveRestartBtn.style.display = 'flex';
                } else {
                    saveRestartBtn.classList.remove('visible');
                    floatingSaveRestartBtn.style.display = 'none';
                }

                // Floating bar visibility based on scroll position
                updateFloatingBarVisibility();
            } else {
                // Hide unsaved indicator
                unsavedIndicator.classList.add('hidden');
                saveBar.classList.add('hidden');
                document.body.classList.remove('has-unsaved');

                // Disable save/discard buttons
                saveBtn.disabled = true;
                discardBtn.disabled = true;

                // Hide Save & Restart buttons
                saveRestartBtn.classList.remove('visible');
                floatingSaveRestartBtn.style.display = 'none';

                requiresRestart = false;
            }
        }

        // Show floating bar only when Actions section is scrolled out of view
        function updateFloatingBarVisibility() {
            const actionsSection = document.getElementById('actionsSection');
            const saveBar = document.getElementById('saveBar');
            const hasChanges = Object.keys(pendingChanges).length > 0;

            if (!hasChanges) {
                saveBar.classList.add('hidden');
                return;
            }

            const rect = actionsSection.getBoundingClientRect();
            const isActionsVisible = rect.top < window.innerHeight && rect.bottom > 0;

            if (isActionsVisible) {
                saveBar.classList.add('hidden');
            } else {
                saveBar.classList.remove('hidden');
            }
        }

        // Mark input as changed
        function markInputChanged(elementId, changed) {
            const el = document.getElementById(elementId);
            if (!el) return;

            if (el.type === 'checkbox') {
                const slider = el.nextElementSibling;
                if (slider) {
                    if (changed) slider.classList.add('changed');
                    else slider.classList.remove('changed');
                }
            } else {
                if (changed) el.classList.add('input-changed');
                else el.classList.remove('input-changed');
            }
        }

        // Save all pending changes
        async function saveChanges() {
            if (Object.keys(pendingChanges).length === 0) {
                showToast('No changes to save', 'warning');
                return;
            }

            try {
                // Save each pending change
                for (const [elementId, change] of Object.entries(pendingChanges)) {
                    const response = await fetch('/api/config', {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(change)
                    });

                    const result = await response.json();
                    if (result.success) {
                        config = result.config;
                        markInputChanged(elementId, false);
                    }
                }

                originalConfig = JSON.parse(JSON.stringify(config));
                pendingChanges = {};

                if (requiresRestart) {
                    showToast('Saved! Restart required for some changes to take effect.', 'warning');
                } else {
                    showToast('Settings saved', 'success');
                }

                requiresRestart = false;
                updateSaveBar();

            } catch (error) {
                showToast('Failed to save settings', 'error');
                console.error('Error saving config:', error);
            }
        }

        // Save and restart
        async function saveAndRestart() {
            if (Object.keys(pendingChanges).length === 0) {
                // No changes, just restart
                await restartService();
                return;
            }

            try {
                // Save all changes first
                for (const [elementId, change] of Object.entries(pendingChanges)) {
                    await fetch('/api/config', {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(change)
                    });
                }

                showToast('Settings saved. Restarting service...', 'success');
                pendingChanges = {};
                requiresRestart = false;
                updateSaveBar();

                // Now restart
                await restartService();

            } catch (error) {
                showToast('Failed to save and restart', 'error');
                console.error('Error:', error);
            }
        }

        // Restart the service
        async function restartService() {
            try {
                showToast('Restarting service...', 'warning');

                const response = await fetch('/api/restart', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const result = await response.json();

                if (result.success) {
                    showToast('Service restarting. Page will reload...', 'success');

                    // Wait for service to restart, then reload
                    setTimeout(() => {
                        window.location.reload();
                    }, 3000);
                } else {
                    showToast('Failed to restart: ' + result.error, 'error');
                }

            } catch (error) {
                showToast('Failed to restart service', 'error');
                console.error('Error restarting:', error);
            }
        }

        // Discard pending changes
        function discardChanges() {
            // Reset UI to original values
            updateUI(originalConfig);

            // Clear all changed indicators
            for (const elementId of Object.keys(pendingChanges)) {
                markInputChanged(elementId, false);
            }

            pendingChanges = {};
            requiresRestart = false;
            updateSaveBar();

            showToast('Changes discarded', 'success');
        }

        // Reset configuration
        async function resetConfig() {
            if (!confirm('Reset all settings to defaults?')) return;

            try {
                const response = await fetch('/api/config/reset', { method: 'POST' });
                const result = await response.json();

                if (result.success) {
                    config = result.config;
                    updateUI(config);
                    showToast('Reset to defaults', 'success');
                }
            } catch (error) {
                showToast('Failed to reset', 'error');
                console.error('Error resetting config:', error);
            }
        }

        // Export configuration
        function exportConfig() {
            const json = JSON.stringify(config, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'activity-tracker-config.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Configuration exported', 'success');
        }

        // Show toast notification
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Quality preset definitions
        const qualityPresets = {
            quick: { max_samples: 5, include_previous_summary: false, focus_weighted_sampling: false },
            balanced: { max_samples: 10, include_previous_summary: true, focus_weighted_sampling: true },
            thorough: { max_samples: 15, include_previous_summary: true, focus_weighted_sampling: true }
        };

        // Apply quality preset to underlying settings
        function applyQualityPreset(preset) {
            const settings = qualityPresets[preset];
            if (!settings) return;

            // Update UI
            setValue('max_samples', settings.max_samples);
            setChecked('include_previous_summary', settings.include_previous_summary);
            setChecked('focus_weighted_sampling', settings.focus_weighted_sampling);

            // Track changes
            trackChange('max_samples', 'summarization', 'max_samples', settings.max_samples);
            trackChange('include_previous_summary', 'summarization', 'include_previous_summary', settings.include_previous_summary);
            trackChange('focus_weighted_sampling', 'summarization', 'focus_weighted_sampling', settings.focus_weighted_sampling);

            updatePresetBadge();
            updatePromptTemplate();  // Preset affects include_previous_summary
        }

        // Update the preset badge display
        function updatePresetBadge() {
            const preset = document.getElementById('quality_preset')?.value || 'balanced';
            const badge = document.getElementById('currentPresetBadge');
            if (badge) badge.textContent = preset;
        }

        // Update computed trigger threshold display (display only, no tracking)
        function updateTriggerThresholdDisplay() {
            const frequency = parseInt(document.getElementById('frequency_minutes')?.value || 15);
            const captureInterval = config?.capture?.interval_seconds || 30;
            const threshold = Math.round(frequency * 60 / captureInterval);
            const display = document.getElementById('trigger_threshold_display');
            if (display) display.textContent = `${threshold} screenshots`;
            return threshold;  // Return for use when tracking is needed
        }

        // Toggle advanced settings visibility
        function toggleAdvancedSettings() {
            const container = document.getElementById('advancedSettings');
            const arrow = document.getElementById('advancedArrow');
            container.classList.toggle('collapsed');
            arrow.classList.toggle('expanded');
        }

        // Toggle prompt preview visibility
        function togglePromptPreview() {
            const container = document.getElementById('promptPreview');
            const toggleText = document.getElementById('promptToggleText');
            const isCollapsed = container.classList.toggle('collapsed');
            toggleText.textContent = isCollapsed ? 'Show' : 'Hide';

            // Update prompt template when shown
            if (!isCollapsed) {
                updatePromptTemplate();
            }
        }

        // Build prompt template dynamically based on selected content options
        function updatePromptTemplate() {
            const includeFocus = document.getElementById('include_focus_context')?.checked;
            const includeScreenshots = document.getElementById('include_screenshots')?.checked;
            const includeOcr = document.getElementById('include_ocr')?.checked;
            const includePrevious = document.getElementById('include_previous_summary')?.checked;

            let parts = ['You are summarizing a developer\'s work activity.', ''];

            if (includePrevious) {
                parts.push('[Previous context: {previous_summary}]');
                parts.push('');
            }

            if (includeFocus) {
                parts.push('## Time Breakdown (from focus tracking)');
                parts.push('- VS Code (daemon.py): 45m 23s [longest: 18m]');
                parts.push('- Firefox (GitHub PR #1234): 12m 5s [3 visits]');
                parts.push('- Terminal: 8m 12s [5 visits]');
                parts.push('');
                parts.push('Total tracked: 65m, 12 context switches');
                parts.push('');
            }

            if (includeOcr) {
                parts.push('## Window Content (OCR)');
                parts.push('{ocr_section}');
                parts.push('');
            }

            if (includeScreenshots) {
                parts.push('## Screenshots');
                parts.push('{num_screenshots} screenshots attached showing actual screen content.');
                parts.push('');
            }

            // Build the "based on" clause dynamically
            let sources = [];
            if (includeFocus) sources.push('the time breakdown');
            if (includeOcr) sources.push('OCR text');
            if (includeScreenshots) sources.push('screenshots');

            const basis = sources.length > 0 ? sources.join(', ') : 'the available data';

            parts.push(`Based on ${basis}, write ONE sentence (max 25 words) describing the PRIMARY activity.`);
            parts.push('');
            parts.push('IMPORTANT: Output ONLY the summary sentence. No explanation, no reasoning, no preamble.');
            parts.push('');
            parts.push('Guidelines:');
            parts.push('- Focus on where the most time was spent');
            parts.push('- Use specific project names, filenames, or URLs visible in the content');
            parts.push('- Format: "[Action verb] [what] in/for [project/context]"');
            parts.push('- If multiple distinct activities, mention the dominant one');
            parts.push('- Do NOT assume different apps/windows are related unless clearly the same project');
            parts.push('');
            parts.push('Good examples:');
            parts.push('Implementing window focus tracking in activity-tracker daemon.py (45 min)');
            parts.push('Reviewing PR #1234 for authentication service and responding to comments');
            parts.push('Debugging API endpoint issues in Acusight backend with Docker logs');
            parts.push('');
            parts.push('Be specific. Avoid generic descriptions like "coding" or "browsing".');

            const template = parts.join('\n');
            document.getElementById('promptTemplateText').textContent = template;

            // Add visual indicator for disabled sections
            const preEl = document.getElementById('promptTemplateText');
            if (!includeFocus && !includeScreenshots && !includeOcr) {
                preEl.style.color = 'var(--danger)';
                preEl.textContent = ' Warning: No content selected! At least one option must be enabled.\n\n' + template;
            } else {
                preEl.style.color = '';
            }
        }

        // Event listeners for all inputs
        document.addEventListener('DOMContentLoaded', () => {
            loadConfig();

            // Listen for scroll to update floating bar visibility
            window.addEventListener('scroll', updateFloatingBarVisibility);

            // Range inputs
            ['interval_seconds', 'quality', 'timeout_seconds', 'min_session_minutes',
             'max_days_retention', 'max_gb_storage', 'max_samples'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', (e) => {
                        updateSliderValue(id, e.target.value);
                        const { section, key } = getConfigInfo(id);
                        const value = id === 'max_gb_storage'
                            ? parseFloat(e.target.value)
                            : parseInt(e.target.value);
                        trackChange(id, section, key, value);
                    });
                }
            });

            // Checkboxes
            const promptAffectingCheckboxes = ['include_focus_context', 'include_screenshots', 'include_ocr', 'include_previous_summary'];

            ['capture_active_monitor_only', 'summarization_enabled', 'include_previous_summary',
             'crop_to_window', 'focus_weighted_sampling',
             'include_focus_context', 'include_screenshots', 'include_ocr'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', (e) => {
                        const { section, key } = getConfigInfo(id);
                        trackChange(id, section, key, e.target.checked);

                        // Update prompt template preview if this checkbox affects it
                        if (promptAffectingCheckboxes.includes(id)) {
                            updatePromptTemplate();
                        }
                    });
                }
            });

            // Select inputs (basic)
            ['format', 'model'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', (e) => {
                        const { section, key } = getConfigInfo(id);
                        trackChange(id, section, key, e.target.value);
                    });
                }
            });

            // Frequency dropdown - compute trigger threshold
            const frequencyEl = document.getElementById('frequency_minutes');
            if (frequencyEl) {
                frequencyEl.addEventListener('change', (e) => {
                    trackChange('frequency_minutes', 'summarization', 'frequency_minutes', parseInt(e.target.value));
                    const threshold = updateTriggerThresholdDisplay();
                    trackChange('trigger_threshold', 'summarization', 'trigger_threshold', threshold);
                });
            }

            // Quality preset dropdown - apply preset settings
            const qualityEl = document.getElementById('quality_preset');
            if (qualityEl) {
                qualityEl.addEventListener('change', (e) => {
                    trackChange('quality_preset', 'summarization', 'quality_preset', e.target.value);
                    applyQualityPreset(e.target.value);
                });
            }

            // Text inputs
            const ollamaHostInput = document.getElementById('ollama_host');
            if (ollamaHostInput) {
                ollamaHostInput.addEventListener('change', (e) => {
                    trackChange('ollama_host', 'summarization', 'ollama_host', e.target.value);
                });
            }

            // Tag input - track changes for excluded apps
            const tagInput = document.getElementById('excluded_apps_input');
            if (tagInput) {
                tagInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.target.value.trim()) {
                        const value = e.target.value.trim();
                        // Create a working copy of excluded apps
                        let apps = pendingChanges['excluded_apps']?.value
                            || [...config.privacy.excluded_apps];
                        if (!apps.includes(value)) {
                            apps.push(value);
                            trackChange('excluded_apps', 'privacy', 'excluded_apps', apps);
                            updateTags('excluded_apps', apps);
                        }
                        e.target.value = '';
                        e.preventDefault();
                    }
                });
            }
        });

        // Mapping from element IDs to config {section, key}
        const configMapping = {
            // Capture
            interval_seconds: { section: 'capture', key: 'interval_seconds' },
            format: { section: 'capture', key: 'format' },
            quality: { section: 'capture', key: 'quality' },
            capture_active_monitor_only: { section: 'capture', key: 'capture_active_monitor_only' },
            // AFK
            timeout_seconds: { section: 'afk', key: 'timeout_seconds' },
            min_session_minutes: { section: 'afk', key: 'min_session_minutes' },
            // Summarization - User-facing settings
            summarization_enabled: { section: 'summarization', key: 'enabled' },
            model: { section: 'summarization', key: 'model' },
            frequency_minutes: { section: 'summarization', key: 'frequency_minutes' },
            quality_preset: { section: 'summarization', key: 'quality_preset' },
            // Content mode (multi-select)
            include_focus_context: { section: 'summarization', key: 'include_focus_context' },
            include_screenshots: { section: 'summarization', key: 'include_screenshots' },
            include_ocr: { section: 'summarization', key: 'include_ocr' },
            // Advanced settings
            ollama_host: { section: 'summarization', key: 'ollama_host' },
            crop_to_window: { section: 'summarization', key: 'crop_to_window' },
            trigger_threshold: { section: 'summarization', key: 'trigger_threshold' },
            max_samples: { section: 'summarization', key: 'max_samples' },
            include_previous_summary: { section: 'summarization', key: 'include_previous_summary' },
            focus_weighted_sampling: { section: 'summarization', key: 'focus_weighted_sampling' },
            sample_interval_minutes: { section: 'summarization', key: 'sample_interval_minutes' },
            // Storage
            data_dir: { section: 'storage', key: 'data_dir' },
            max_days_retention: { section: 'storage', key: 'max_days_retention' },
            max_gb_storage: { section: 'storage', key: 'max_gb_storage' },
            // Privacy
            excluded_apps: { section: 'privacy', key: 'excluded_apps' },
            excluded_titles: { section: 'privacy', key: 'excluded_titles' },
            blur_screenshots: { section: 'privacy', key: 'blur_screenshots' },
            // Web
            host: { section: 'web', key: 'host' },
            port: { section: 'web', key: 'port' },
        };

        function getConfigInfo(elementId) {
            return configMapping[elementId] || { section: 'capture', key: elementId };
        }

        // ==================== Tag Management Functions ====================

        let tagConsolidationData = [];  // Store suggested consolidations
        let allTagsData = [];  // Store all tags for cloud
        let selectedTags = new Set();  // Currently selected tags for manual merge

        // Load tags and render cloud
        async function loadTagCloud() {
            const cloud = document.getElementById('tagCloud');
            try {
                const response = await fetch('/api/tags');
                const data = await response.json();
                allTagsData = data.tags || [];

                document.getElementById('uniqueTagCount').textContent = data.total_unique || allTagsData.length;

                // Render tag cloud
                cloud.innerHTML = '';
                if (allTagsData.length === 0) {
                    cloud.innerHTML = '<span class="loading-text">No tags found</span>';
                    return;
                }

                allTagsData.forEach(t => {
                    const tag = document.createElement('span');
                    tag.className = 'tag-cloud-item';
                    tag.dataset.tag = t.tag;
                    tag.innerHTML = `${escapeHtml(t.tag)} <span class="tag-count">(${t.count})</span>`;
                    tag.onclick = () => toggleTagSelection(t.tag, tag);
                    cloud.appendChild(tag);
                });
            } catch (error) {
                console.error('Error loading tags:', error);
                cloud.innerHTML = '<span class="loading-text">Error loading tags</span>';
            }
        }

        // Toggle tag selection for manual merge
        function toggleTagSelection(tagName, element) {
            if (selectedTags.has(tagName)) {
                selectedTags.delete(tagName);
                element.classList.remove('selected');
            } else {
                selectedTags.add(tagName);
                element.classList.add('selected');
            }
            updateMergeControls();
        }

        // Update merge controls visibility and state
        function updateMergeControls() {
            const controls = document.getElementById('mergeControls');
            const countEl = document.getElementById('selectedTagsCount');
            const input = document.getElementById('canonicalTagInput');

            countEl.textContent = selectedTags.size;

            if (selectedTags.size >= 2) {
                controls.style.display = 'block';
                // Auto-suggest canonical name (most common tag or first selected)
                if (!input.value) {
                    const tags = Array.from(selectedTags);
                    const mostCommon = tags.reduce((a, b) => {
                        const countA = allTagsData.find(t => t.tag === a)?.count || 0;
                        const countB = allTagsData.find(t => t.tag === b)?.count || 0;
                        return countA >= countB ? a : b;
                    });
                    input.value = mostCommon.toLowerCase().replace(/\s+/g, '-');
                }
            } else {
                controls.style.display = 'none';
            }
        }

        // Clear tag selection
        function clearTagSelection() {
            selectedTags.clear();
            document.querySelectorAll('.tag-cloud-item.selected').forEach(el => el.classList.remove('selected'));
            document.getElementById('canonicalTagInput').value = '';
            updateMergeControls();
        }

        // Filter tag cloud by search input
        function filterTagCloud() {
            const filter = document.getElementById('tagSearchInput').value.toLowerCase();
            document.querySelectorAll('.tag-cloud-item').forEach(el => {
                const tag = el.dataset.tag.toLowerCase();
                el.classList.toggle('hidden', filter && !tag.includes(filter));
            });
        }

        // Merge selected tags manually
        async function mergeSelectedTags() {
            const canonical = document.getElementById('canonicalTagInput').value.trim();
            if (!canonical) {
                showToast('Please enter a canonical tag name', 'error');
                return;
            }
            if (selectedTags.size < 2) {
                showToast('Select at least 2 tags to merge', 'error');
                return;
            }

            const variants = Array.from(selectedTags);
            const btn = document.getElementById('mergeTagsBtn');
            btn.disabled = true;

            try {
                const response = await fetch('/api/tags/consolidate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        consolidations: [{ canonical, variants }]
                    })
                });

                const data = await response.json();
                if (data.error) throw new Error(data.error);

                showToast(`Merged ${variants.length} tags into "${canonical}", updated ${data.updated_summaries} summaries`, 'success');
                clearTagSelection();
                loadTagCloud();  // Refresh cloud

            } catch (error) {
                showToast(`Error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
            }
        }

        // Analyze tags for auto-detected duplicates
        async function analyzeTagsForConsolidation() {
            const btn = document.getElementById('analyzeTagsBtn');
            const resultsDiv = document.getElementById('tagConsolidationResults');

            btn.disabled = true;
            resultsDiv.style.display = 'none';

            try {
                const response = await fetch('/api/tags/suggest-consolidation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ min_count: 1 })
                });

                const data = await response.json();
                if (data.error) throw new Error(data.error);

                tagConsolidationData = data.consolidations || [];

                if (tagConsolidationData.length === 0) {
                    showToast('No duplicate tags found', 'success');
                    return;
                }

                renderConsolidationSuggestions(tagConsolidationData);
                resultsDiv.style.display = 'block';

            } catch (error) {
                showToast(`Error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
            }
        }

        // Render consolidation suggestions
        function renderConsolidationSuggestions(consolidations) {
            const list = document.getElementById('consolidationList');
            list.innerHTML = '';

            consolidations.forEach((group, index) => {
                const item = document.createElement('div');
                item.className = 'consolidation-item';
                item.dataset.index = index;

                const variantsHtml = group.variants.map(v =>
                    `<span class="variant-tag ${v === group.canonical ? 'canonical' : ''}">${escapeHtml(v)}</span>`
                ).join('');

                item.innerHTML = `
                    <input type="checkbox" class="consolidation-checkbox" data-index="${index}" onchange="updateConsolidationSelection()">
                    <div class="consolidation-content">
                        <div class="consolidation-canonical">
                            <span class="arrow"></span> ${escapeHtml(group.canonical)}
                        </div>
                        <div class="consolidation-variants">
                            ${variantsHtml}
                        </div>
                        <div class="consolidation-count">
                            ${group.total_count || 0} occurrences across ${group.variants.length} variants
                        </div>
                    </div>
                `;

                // Click on item to toggle checkbox
                item.addEventListener('click', (e) => {
                    if (e.target.type !== 'checkbox') {
                        const checkbox = item.querySelector('.consolidation-checkbox');
                        checkbox.checked = !checkbox.checked;
                        updateConsolidationSelection();
                    }
                });

                list.appendChild(item);
            });
        }

        // Toggle all consolidation checkboxes
        function toggleAllConsolidations() {
            const selectAll = document.getElementById('selectAllConsolidations').checked;
            document.querySelectorAll('.consolidation-checkbox').forEach(cb => {
                cb.checked = selectAll;
            });
            updateConsolidationSelection();
        }

        // Update selection state and enable/disable apply button
        function updateConsolidationSelection() {
            const checkboxes = document.querySelectorAll('.consolidation-checkbox');
            const applyBtn = document.getElementById('applyConsolidationsBtn');
            const selectedCount = Array.from(checkboxes).filter(cb => cb.checked).length;

            applyBtn.disabled = selectedCount === 0;
            applyBtn.textContent = selectedCount > 0 ? `Apply Selected (${selectedCount})` : 'Apply Selected';

            // Update item selected state
            checkboxes.forEach(cb => {
                const item = cb.closest('.consolidation-item');
                item.classList.toggle('selected', cb.checked);
            });

            // Update select all checkbox state
            const selectAll = document.getElementById('selectAllConsolidations');
            selectAll.checked = selectedCount === checkboxes.length && checkboxes.length > 0;
            selectAll.indeterminate = selectedCount > 0 && selectedCount < checkboxes.length;
        }

        // Apply selected consolidations
        async function applySelectedConsolidations() {
            const checkboxes = document.querySelectorAll('.consolidation-checkbox:checked');
            const selectedIndices = Array.from(checkboxes).map(cb => parseInt(cb.dataset.index));

            if (selectedIndices.length === 0) {
                showToast('No consolidations selected', 'error');
                return;
            }

            const selectedConsolidations = selectedIndices.map(i => tagConsolidationData[i]);

            const applyBtn = document.getElementById('applyConsolidationsBtn');
            applyBtn.disabled = true;
            applyBtn.textContent = 'Applying...';

            try {
                const response = await fetch('/api/tags/consolidate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ consolidations: selectedConsolidations })
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                showToast(`Consolidated ${data.tags_consolidated} tag groups, updated ${data.updated_summaries} summaries`, 'success');

                // Hide results and refresh tag cloud
                cancelConsolidation();
                loadTagCloud();

            } catch (error) {
                showToast(`Error: ${error.message}`, 'error');
                console.error('Consolidation error:', error);
            } finally {
                applyBtn.disabled = false;
                updateConsolidationSelection();
            }
        }

        // Cancel consolidation (hide results)
        function cancelConsolidation() {
            document.getElementById('tagConsolidationResults').style.display = 'none';
            document.getElementById('selectAllConsolidations').checked = false;
            tagConsolidationData = [];
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            loadTagCloud();

            // Button event listeners
            document.getElementById('refreshModelsBtn').addEventListener('click', loadOllamaModels);
            document.getElementById('advancedToggle').addEventListener('click', toggleAdvancedSettings);
            document.getElementById('promptPreviewToggle').addEventListener('click', togglePromptPreview);
            document.getElementById('tagSearchInput').addEventListener('input', filterTagCloud);
            document.getElementById('analyzeTagsBtn').addEventListener('click', analyzeTagsForConsolidation);
            document.getElementById('clearTagsBtn').addEventListener('click', clearTagSelection);
            document.getElementById('mergeTagsBtn').addEventListener('click', mergeSelectedTags);
            document.getElementById('selectAllConsolidations').addEventListener('change', toggleAllConsolidations);
            document.getElementById('applyConsolidationsBtn').addEventListener('click', applySelectedConsolidations);
            document.getElementById('cancelConsolidationBtn').addEventListener('click', cancelConsolidation);
            document.getElementById('saveBtn').addEventListener('click', saveChanges);
            document.getElementById('saveRestartBtn').addEventListener('click', saveAndRestart);
            document.getElementById('discardBtn').addEventListener('click', discardChanges);
            document.getElementById('exportConfigBtn').addEventListener('click', exportConfig);
            document.getElementById('resetConfigBtn').addEventListener('click', resetConfig);
            document.getElementById('floatingSaveBtn').addEventListener('click', saveChanges);
            document.getElementById('floatingSaveRestartBtn').addEventListener('click', saveAndRestart);

            // Event delegation for dynamically created tag remove buttons
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tag-remove')) {
                    const containerId = e.target.dataset.container;
                    const tag = e.target.dataset.tag;
                    if (containerId && tag) {
                        removeTag(containerId, tag);
                    }
                }
            });
        });
    </script>
{% endblock %}
